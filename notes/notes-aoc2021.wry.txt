:project Advent of code 2021
   :created 2021-12-10
   :author Mike Weaver

:section Introduction
   These are my notes and thoughts on the AoC puzzles of 2021.

:section To Do's

   [] Redo Day-2 with using reduce (instead of loop-recur) and a function that
   switches on a condition based on the command. Also, a re-seq looking for \w+
   and \d+ can then be mapped into keyword and parseInt quite simply.

   [] Day_4 I had an idea to process each bingo card and return back how many
   turns before it won. That would have been a solution I could have used for
   both parts, maybe go back and redo it that way.

   [] I love my solutions for days 5 and 6 and haven't seen anything else out
   there that is better.

:section Day 8

   I modified my original solution (which used some rules to determine
   particular digits after the "unique" digits were solved) to use a
   "fingerprint" approach that I saw described in some random youtube video.

   Idea is to create a 'fingerprint' for each segment, which is the count of
   segments in each digit where the segment appears. For example, segment 'a' is
   in the digits (0 2 3 5 6 7 8 9), and those digits have segment counts of (6 5
   5 5 6 3 7 6), respectively. Sorted, those are (3 5 5 5 6 6 6 7), which is a
   unique fingerprint for segment 'a', or, on the scambled input, for the
   segment which _should_ be 'a'. The other segments 'b' through 'g' likewise
   have unique fingerprints. We fingerprint the randomized input and use it to
   identify the correct segment and ultimately the output digits.

:section Day 15

   Three pieces to this solution, which is an implementation of Dijkstra's
   algorithm:

      1. a 1-dim vector of the input data, `risks`, and the function
      `risk<-loc` that returns the risk for a given 'location' (where a
      'location' is a vector of `[row, col]` and basically lets us treat
      `risks` as if it were a 2-dim matrix);

      2. a set of `visited` locations; and,

      3. a priority-map, `distances`, whose keys are `[r c]` locations and whose
      values are tentative distances. Because `distances` is a priority-map, it
      stays sorted by tentative distance, so after we remove the current node
      from `distances` and add it to `visited` then the next current node is
      simply `(first distances)`.

   Three other implementation notes:

      1. I did not load up `distances` with every location initialized to ##Inf
      as per the standard Dijkstra algorithm. They are instead initialized
      on-the-fly by the `update-distance` function.

      2. For part 2 I did not expand `risks` to be 25 times as big. Instead the
      `risk<-loc` function projects larger coordinates back onto the original
      vector, adjusting the original risk level correspondingly.

      3. I switch from part 1 to part 2 by redefining the var `scale` using
      `with-redefs`.

         :NOTE This `with-redefs` is really cool and probably I'll use it more
         with my code to test sample puzzles. It's kind of a cheaty way to run
         sample problems without having to pass all the config parameters
         through each function. Go ahead and let those configs be namespaced
         def's (I know, globals are considered harmful, but not for simple
         programs like these AoC puzzles) knowing you can temporarily override
         them to run a check on sample inputs.

:section Day 16

   I chose not to have a global atom to help consume the bits. Instead, all my
   parse functions take bits and return a vector `[result bits]`. Consistently,
   then, all calls to these functions destructure the results with this pattern:
      ```
         (defn parse-zzz [bits]
           (let [[result bits] (parse-xxx bits)
                [other bits] (parse-yyy bits)]
             ...do something...
             [result bits])
   I normally don't like clobbering vars with repeating let bindings, but here
   the pattern is useful and consistent. To evaluate the results, I use
   clojure.walk/postwalk which is one of those 'magical' functions that I love
   to use. And first time for me, I used clojure.core.match/match to identify
   the particular subforms (during the walk) that need to be evaluated.

:section Day 17

   Puzzle 1 was done 'by hand' with a calculator and Excel and some knowledge of
   triangle numbers. I confirmed with Excel that for my input, the x-velocity
   could be no lower than 17 otherwise drag would prevent the probe from ever
   reaching the target area. (I made a rough guess by taking the target mid-x,
   doubling, and then taking the square root, and that rough estimate got me
   pretty close.) Obviously the x-velocity has an upper bound of target-max-x.
   In my code, however, I don't bother with the minimum x-velocity because it's
   only a few extra loops to check, and then my code can be run on the sample
   problem with fewer modifications.

   For the y-velocity, we shoot the probe up and when it comes back to y=0, it
   will have negative of it's initial velocity, and then the next y-point it
   hits will be (inc (neg init-y-vel)). So, for example with my input, the
   biggest y-velocity we can choose is 114-1=113. And -114 is the lowest
   y-velocity allowed (continuing with my particular puzzle input) because
   otherwise we completely overshoot the target on the very first step.

   The above logic gives a simple range to test: 0 <= x <= target-max-x and
   target-min-y <= y <= -target-min-y. You could shave a few milliseconds by
   tightening the lower bound for x, but why bother?

:section Day 18

   Zippers! We can query a zipper location for its `path` to see how deep it is
   nested, and the `prev` and `next` functions can find left and right
   neighbors.

   I read the instructions incorrectly and first wrote logic to find the first
   node that was either explodable or splitable and do that. But the
   instructions say otherwise, although I think they could have been clearer:

      1. START

      2. If there are _any_ explodable nodes anywhere in the number, explode the
      left-most and start over.

      3. Else, if there are _any_ splitable nodes, explode the left-most and
      start over.

   Thought: does exploding ever _increase_ the depth of the nodes it touches? I
   don't think it does. So maybe you could change the second step above to "If
   there are any explodable nodes do them all and start over." But I have a
   general function `apply-one-action` that I can use to do a single explode or
   split, and if I changed my logic to do all explosions together, I wouldn't be
   able to use that function.

   I feel like I pulled out all the big guns this time: edn/read-string (which
   did all the work of parsing the input--hooray that commas are whitespace in
   clojure!), zippers, and postwalk.
