:project Advent of Code 2015-d24
   :author Mike Weaver
   :created 2021-01-04

:section A puzzle

   bhauman has a function for generating subsets that is fast, and memoized. I'm
   not 100% sure I understand how it works. I need to walk through a few sample
   iterations to make sure it is solid in my brain.

   But, aside from understanding that, one flaw in his solution--and from
   reading Reddit it is probably similar with many who solved this--there is no
   checking to confirm that a found subset still leaves the remaining numbers
   able to be divided into correct subsets. I liked how one Reddit poster laid
   out the issue, and I created a solution following that outline. That is
   probably saved in some commit in the repository, but is no longer my final
   solution. I might need to revisit it because I had some ideas of optimizing
   it a tiny bit.

   So here is what I learned. bhauman's function is not just creating subsets,
   it is keeping track of the running total so that subsets will add to the
   correct target sum. As a general-purpose, create all subsets function, it
   actually doesn't work, because it doesn't reach the end case and cons onto
   '(), so none of the single-item subsets get generated. But because it
   includes checking that the generated subsets sum to a target, it doesn't
   matter that these small subsets don't ever get reached.

   I did figure out how to write a similar function to return all subsets, it
   uses `concat` and it probaby isn't very fast. I didn't keep it, so hopefully
   I never come back and wish I still had it. I'll just have to re-think it out
   again.

   So after this little side research of understanding bhauman's solution, and
   trying to generate the general solution (without mixing in checking of target
   sum, just generating the subsets) I recreated an early function I had
   written, which builds subsets and checks that they add to the targ. It also
   incorporates a sort of 'reduce' logic and keeps track of the best result
   encountered so far (lowest count, lowest entanglement). So it does everything
   in one all-inclusinve function, but it is sort of ungainly, and hard to read
   and figure out what is going on. Also, it is no faster than the easier to
   understand solution (which ends up generating more subsets, but is still
   fast). But for now, it is my final solution.
