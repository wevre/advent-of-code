:project Advent of Code 2022
   :created 2022-12-01
   :author Mike Weaver

:section Day 01

   My son Isaac was watching me as I hurried to try and do the puzzles before
   taking him to school. He was more interested in the "story" for 2023. Puzzle
   1 was really quick and I was showing him the story and the code and hadn't
   scrolled down yet to see what puzzle 2 was about, but I (correctly) predicted
   to him that it would probably involve parsing the "one" "two" etc that we
   were seeing in the sample input.

   I _did_ notice that some of the words overlapped, but at first I didn't
   consider that valid: I thought "eightwo" should be parsed as "eight" "wo" and
   become only 8. Running my code on the sample data taught me that wasn't
   correct. Then I forgot that, for capture groups, re-seq returns a _vector_ of
   the matches. Unfortunately, because I was 'str'-ingifying values in the
   middle of the transormation chain, my code still sort of worked (in the sense
   that it didn't throw an exception) but just returned wrong values, so it took
   a while to realize.

   Another way to do this, after reading some of the comments on Clojurians
   slack, is to just find the first match of "1|one|2|two..." and the _last_
   match "1|eno|2|owt|..." and then keep just those. This doesn't care about
   overlaps because you just need the first/outermost match.

:section Day 02

   Was it just me or was this much easier than Day 01? I read the problem and
   thought: I only need to know the maximum number of each color pulled out of
   the bag. I don't really need to know (or at least, hopefully when puzzle 2 is
   revealed, I won't need to know) how many sets were drawn for each game, or if
   a set only had one color or any of those details like that. So I didn't model
   sets when I parsed, I just read in a stream of digits and colors, partitioned
   them into groups of two, and reduced them into a map keeping track of the max
   number of cubes seen for each color.

   It was a good gamble, because puzzle 2 also relied only on those max values.

   I did do one refactor for puzzle 2, however. My original keep-only-max map
   was keyed by strings. But when I got to puzzle 2, I wanted to destructure my
   map keys, and ... wait. I can destructure string keys! I forgot. I thought I
   had to turn my colors from strings into keywords so I could destructure them,
   but no, I can destructure string keys. Wow! I forgot about that. I'm going to
   go change that right now.

   So, that's done. As I was saying above, I refactored my keys from strings
   into keywords when I got to puzzle 2. But now I've done a second refactor
   that cancels that out and I'm back to strings as keys, so and I guess I can
   say that net of all these tweaks, I didn't have to change my approach for the
   second puzzle (even though for a brief moment I did---we'll just say that was
   explorative programming, or research, or "art").

:section Day 03

   I have the luxury (on weekends, at least) to be awake at 10pm when the
   puzzles come out, so I can sometimes do them right away. I came up with a
   solution for Day 03 using my already-built `locmap<-` function, which was
   "easy" (and yes, that's a loaded term in the Clojureverse), because it gives
   me a map of positions to characters. But the rest of my solution, especially
   stitching together the part numbers, was convoluted---everything forced to
   deal with the fact that I had (blindly) parsed _first_ and then had to go
   back _after_ to make sense of it all. I submitted my answer and went to bed,
   but I was already thinking of a different approach based on doing my own
   custom parsing and gathering important stuff (like the part numbers) along
   the way.

   I woke up and had a busy morning but was finally able to go try out
   implementing the idea I'd coded in my head last night instead of falling
   asleep. I know others probably did something similar to this approach, but
   the only one I've looked at so far is @zelark's. He parsed each line and made
   good use of the `.start` and `.end` methods in `java.util.regex.Matcher`
   (TIL). Brilliant. I kept to my original idea of parsing the whole thing as a
   stream of characters, treating \newline as just one more character to deal
   with.

   I like this v2 solution. It's shorter, but I also think it is easier to grok,
   which makes sense because I'm not forcing myself into a corner with my
   `locmap<-` function. Don't worry, `locmap<-`, I'm sure there's a GameOfLife
   kind of puzzle coming up and you'll be called into duty.
