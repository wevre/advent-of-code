:project Advent of Code 2022
   :created 2022-12-01
   :author Mike Weaver

:section Day 01

   My son Isaac was watching me as I hurried to try and do the puzzles before
   taking him to school. He was more interested in the "story" for 2023. Puzzle
   1 was really quick and I was showing him the story and the code and hadn't
   scrolled down yet to see what puzzle 2 was about, but I (correctly) predicted
   to him that it would probably involve parsing the "one" "two" etc that we
   were seeing in the sample input.

   I _did_ notice that some of the words overlapped, but at first I didn't
   consider that valid: I thought "eightwo" should be parsed as "eight" "wo" and
   become only 8. Running my code on the sample data taught me that wasn't
   correct. Then I forgot that, for capture groups, re-seq returns a _vector_ of
   the matches. Unfortunately, because I was 'str'-ingifying values in the
   middle of the transormation chain, my code still sort of worked (in the sense
   that it didn't throw an exception) but just returned wrong values, so it took
   a while to realize.

   Another way to do this, after reading some of the comments on Clojurians
   slack, is to just find the first match of "1|one|2|two..." and the _last_
   match "1|eno|2|owt|..." and then keep just those. This doesn't care about
   overlaps because you just need the first/outermost match.

:section Day 02

   Was it just me or was this much easier than Day 01? I read the problem and
   thought: I only need to know the maximum number of each color pulled out of
   the bag. I don't really need to know (or at least, hopefully when puzzle 2 is
   revealed, I won't need to know) how many sets were drawn for each game, or if
   a set only had one color or any of those details like that. So I didn't model
   sets when I parsed, I just read in a stream of digits and colors, partitioned
   them into groups of two, and reduced them into a map keeping track of the max
   number of cubes seen for each color.

   It was a good gamble, because puzzle 2 also relied only on those max values.

   I did do one refactor for puzzle 2, however. My original keep-only-max map
   was keyed by strings. But when I got to puzzle 2, I wanted to destructure my
   map keys, and ... wait. I can destructure string keys! I forgot. I thought I
   had to turn my colors from strings into keywords so I could destructure them,
   but no, I can destructure string keys. Wow! I forgot about that. I'm going to
   go change that right now.

   So, that's done. As I was saying above, I refactored my keys from strings
   into keywords when I got to puzzle 2. But now I've done a second refactor
   that cancels that out and I'm back to strings as keys, so and I guess I can
   say that net of all these tweaks, I didn't have to change my approach for the
   second puzzle (even though for a brief moment I did---we'll just say that was
   explorative programming, or research, or "art").

:section Day 03

   I have the luxury (on weekends, at least) to be awake at 10pm when the
   puzzles come out, so I can sometimes do them right away. I came up with a
   solution for Day 03 using my already-built `locmap<-` function, which was
   "easy" (and yes, that's a loaded term in the Clojureverse), because it gives
   me a map of positions to characters. But the rest of my solution, especially
   stitching together the part numbers, was convoluted---everything forced to
   deal with the fact that I had (blindly) parsed _first_ and then had to go
   back _after_ to make sense of it all. I submitted my answer and went to bed,
   but I was already thinking of a different approach based on doing my own
   custom parsing and gathering important stuff (like the part numbers) along
   the way.

   I woke up and had a busy morning but was finally able to go try out
   implementing the idea I'd coded in my head last night instead of falling
   asleep. I know others probably did something similar to this approach, but
   the only one I've looked at so far is @zelark's. He parsed each line and made
   good use of the `.start` and `.end` methods in `java.util.regex.Matcher`
   (TIL). Brilliant. I kept to my original idea of parsing the whole thing as a
   stream of characters, treating \newline as just one more character to deal
   with.

   I like this v2 solution. It's shorter, but I also think it is easier to grok,
   which makes sense because I'm not forcing myself into a corner with my
   `locmap<-` function. Don't worry, `locmap<-`, I'm sure there's a GameOfLife
   kind of puzzle coming up and you'll be called into duty.

:section Day 04

   I chose not so stay up later on Sunday night to work on this, so just tackled
   it in the morning, in between waking up kids and getting lunches ready. Part
   1 was very easy. For part 2, I did a straightforward solution probably
   similar to everyone else. I had a hunch there was some more 'mathmatical' way
   to do it rather than just incrementing buckets, but I didn't want to try and
   figure it out.

   After I posted and started reading through the Clojurians slack, Sam Ferrell
   had implemented that other way. As @genmeblog aptly stated, it's the
   difference between reverse processing and forward processing. I created a v2
   to try out Sam's approach and, because I was curious, to test out execution
   times. This data probably isn't large enough to really tell, but the reverse
   approach appears to be slightly faster. And, bonus, you don't have to keep
   track of card numbers.

:section Day 05

   We got home late from a party so I decided to stay up and tackle day 05
   instead of (what I should have done) going to bed. The first part was easy
   and I should have guessed at what would be coming up in part 2. Even though I
   knew it wouldn't work, I tried the brute force approach of sending nearly 2
   billion seed values through the chain of maps like I'd done for part 1. Of
   course that would take way to long, so then I knew I had to deal with
   sub-dividing ranges. I haven't gone back to go find it, but it seems like
   there was a 3-D version of this same type of problem in a previous year.

   I had used `reduced` in my 1-D solution, so when I adapted all the code over
   to 2-D I kept that in there. Once I successfully mapped a sub-range from src
   to dst, I marked it as reduced and skipped it in later sweeps. I guess the
   other way to approach that is to keep two lists, one for ranges that haven't
   been mapped yet, and one for those that have. I just kept one list but
   started marking converted ranges with reduced.

   I wanted to do some refactoring on my parsing logic, since I had two or three
   steps of input parsing logic repeated for both puzzles, but I went to bed
   instead. When I got up this morning, I did that refactoring and I also went
   back and cleaned up by break-up-a-range-into-sub-ranges logic a little bit.
   It's still the same logic and approach, but I think this version is a little
   easier (maybe?) to understand what is going on. Instead dealing with each of
   the six overlap/subrange cases (where there is some repeated logic among
   the six cases), I boiled that down to generating three (possibly invalid)
   sub-ranges, and drop any that have negative lengths.

:section Day 06

   I solved this with pen and paper. It's just the quadratic formula.

:section Day 07
